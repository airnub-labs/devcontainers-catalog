import { mkdir, readFile, writeFile, stat } from 'node:fs/promises';
import path from 'node:path';
import { createPatch } from 'diff';

export type CommentStyle = 'hash' | 'slash' | 'html' | 'none';

export interface ManagedFileOptions {
  commentStyle: CommentStyle;
  version: string;
  catalogRef: string;
  previewDir?: string;
}

export interface ManagedWriteResult {
  changed: boolean;
  path: string;
  patchPath?: string;
}

export async function ensureDir(targetDir: string): Promise<void> {
  await mkdir(targetDir, { recursive: true });
}

function commentLine(style: CommentStyle, text: string): string {
  switch (style) {
    case 'hash':
      return `# ${text}`;
    case 'slash':
      return `// ${text}`;
    case 'html':
      return `<!-- ${text} -->`;
    default:
      return text;
  }
}

function beginMarker(style: CommentStyle): string {
  switch (style) {
    case 'hash':
      return '# >>> BEGIN MANAGED BLOCK';
    case 'slash':
      return '// >>> BEGIN MANAGED BLOCK';
    case 'html':
      return '<!-- >>> BEGIN MANAGED BLOCK -->';
    default:
      return '>>> BEGIN MANAGED BLOCK';
  }
}

function endMarker(style: CommentStyle): string {
  switch (style) {
    case 'hash':
      return '# <<< END MANAGED BLOCK';
    case 'slash':
      return '// <<< END MANAGED BLOCK';
    case 'html':
      return '<!-- <<< END MANAGED BLOCK -->';
    default:
      return '<<< END MANAGED BLOCK';
  }
}

function normalizeNewline(content: string): string {
  return content.replace(/\r\n/g, '\n');
}

export async function writeManagedFile(
  filePath: string,
  managedBody: string,
  options: ManagedFileOptions
): Promise<ManagedWriteResult> {
  const header = commentLine(
    options.commentStyle,
    `Generated by @airnub/devc v${options.version} (catalog-ref=${options.catalogRef}) â€” do not edit outside marked regions.`
  );
  const begin = beginMarker(options.commentStyle);
  const end = endMarker(options.commentStyle);
  const normalizedBody = normalizeNewline(managedBody.trimEnd());
  let block = `${begin}\n${normalizedBody}\n${end}`;
  if (!block.endsWith('\n')) {
    block += '\n';
  }
  let finalContent = `${header}\n${block}`;
  if (!finalContent.endsWith('\n')) {
    finalContent += '\n';
  }

  let existing = '';
  try {
    existing = normalizeNewline(await readFile(filePath, 'utf8'));
  } catch (error) {
    existing = '';
  }

  let nextContent = finalContent;
  if (existing.includes(begin) && existing.includes(end)) {
    const afterEndIndex = existing.indexOf(end) + end.length;
    const suffix = existing.slice(afterEndIndex).replace(/^\n?/, '\n');
    nextContent = `${finalContent.trimEnd()}${suffix}`;
  }

  const changed = normalizeNewline(existing).trimEnd() !== nextContent.trimEnd();
  if (changed) {
    await ensureDir(path.dirname(filePath));
    await writeFile(filePath, `${nextContent.trimEnd()}\n`);
    let patchPath: string | undefined;
    if (options.previewDir) {
      await ensureDir(options.previewDir);
      const patch = createPatch(filePath, existing, `${nextContent.trimEnd()}\n`, 'previous', 'next');
      const previewPath = path.join(options.previewDir, `${path.basename(filePath)}.patch`);
      await writeFile(previewPath, patch);
      patchPath = previewPath;
    }
    return { changed: true, path: filePath, patchPath };
  }

  return { changed: false, path: filePath };
}

export async function pathExists(target: string): Promise<boolean> {
  try {
    await stat(target);
    return true;
  } catch (error) {
    return false;
  }
}
